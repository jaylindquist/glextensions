#summary GL_EXT_timer_query

== Contents ==

  * [GL_EXT_timer_query#Dependencies Dependencies]
  * [GL_EXT_timer_query#Overview Overview]
  * [GL_EXT_timer_query#New_Procedures_and_Functions New Procedures and Functions]
  * [GL_EXT_timer_query#New_Tokens New Tokens]
  * [GL_EXT_timer_query#Errors Errors]
  * [GL_EXT_timer_query#New_State New State]
  * [GL_EXT_timer_query#New_Implementation_Dependent_State New Implementation Dependent State]

== Dependencies ==

Written based on the wording of the OpenGL 2.0 specification.

OpenGL 1.5 is required.

This extension modifies [GL_ARB_occlusion_query] and [GL_NV_occlusion_query].


== Overview ==

Applications can benefit from accurate timing information in a number of
different ways.  During application development, timing information can
help identify application or driver bottlenecks.  At run time,
applications can use timing information to dynamically adjust the amount
of detail in a scene to achieve constant frame rates.  OpenGL
implementations have historically provided little to no useful timing
information.  Applications can get some idea of timing by reading timers
on the CPU, but these timers are not synchronized with the graphics
rendering pipeline.  Reading a CPU timer does not guarantee the completion
of a potentially large amount of graphics work accumulated before the
timer is read, and will thus produce wildly inaccurate results.
glFinish() can be used to determine when previous rendering commands have
been completed, but will idle the graphics pipeline and adversely affect
application performance.

This extension provides a query mechanism that can be used to determine
the amount of time it takes to fully complete a set of GL commands, and
without stalling the rendering pipeline.  It uses the query object
mechanisms first introduced in the occlusion query extension, which allow
time intervals to be polled asynchronously by the application.


== New Procedures and Functions ==
{{{
void GetQueryObjecti64vEXT(uint id, enum pname, int64EXT *params);
void GetQueryObjectui64vEXT(uint id, enum pname, uint64EXT *params);
}}}

== New Tokens ==

Accepted by the <target> parameter of !BeginQuery, !EndQuery, and
!GetQueryiv:

||TIME_ELAPSED_EXT||0x88BF||


== Errors ==

All existing errors for query objects apply unchanged from the
ARB_occlusion_query spec, except the modification below:

The error INVALID_ENUM is generated if BeginQueryARB, EndQueryARB, or
GetQueryivARB is called where <target> is not SAMPLES_PASSED or
TIME_ELAPSED_EXT.

The error INVALID_OPERATION is generated if GetQueryObjecti64vEXT or
GetQueryObjectui64vEXT is called where <id> is not the name of a query
object.

The error INVALID_OPERATION is generated if GetQueryObjecti64vEXT or
GetQueryObjectui64vEXT is called where <id> is the name of a currently
active query object.

The error INVALID_ENUM is generated if GetQueryObjecti64vEXT or
GetQueryObjectui64vEXT is called where <pname> is not QUERY_RESULT or
QUERY_RESULT_AVAILABLE.


== New State ==

|| *Get Value* || *Type* || *Get Command* || *Init. Value* || *Description* ||
||CURRENT_QUERY||2xZ+||!GetQueryiv||0||Active query object name (occlusion and timer)||
||QUERY_RESULT||2xZ+||!GetQueryObjectiv||0||Query object result (samples passed or time elapsed)||
||QUERY_RESULT_AVAILABLE||2xB||!GetQueryObjectiv||TRUE||Query object result available?||


== New Implementation Dependent State ==

|| *Get Value* || *Type* || *Get Command* || *Minimum Value* || *Description* ||
||QUERY_COUNTER_BITS||2xZ+||!GetQueryiv||see 6.1.12||Asynchronous query counter bits (occlusion and timer queries)||

